[gd_resource type="Shader" format=3 uid="uid://wnw8t32kt5yq"]

[resource]
code = "shader_type particles;

uniform float radius = 0.1;
uniform float amount = 50.0;

float rand_from_seed(inout uint seed) {
	int k;
	int s = int(seed);
	if (s == 0)
	s = 305420679;
	k = s / 127773;
	s = 16807 * (s - k * 127773) - 2836 * k;
	if (s < 0)
		s += 2147483647;
	seed = uint(s);
	return float(seed % uint(65536)) / 65535.0;
}

float rand_from_seed_m1_p1(inout uint seed) {
	return rand_from_seed(seed) * 2.0 - 1.0;
}


uint hash(uint x) {
	x = ((x >> uint(16)) ^ x) * uint(73244475);
	x = ((x >> uint(16)) ^ x) * uint(73244475);
	x = (x >> uint(16)) ^ x;
	return x;
}

float get_shift_direction(float droplet_axis, float emission_axis) {
	// 1.0 if positive shift, -1.0 if negative shift
	bool is_negative_shift = droplet_axis - emission_axis < 0.0;
	return 1.0 - 1.0 * 2.0 * float(is_negative_shift);
}

void process() {
	uint base_number = NUMBER;
	uint alt_seed = hash(base_number + uint(1) + RANDOM_SEED);
	if (RESTART) {
		
		vec3 rand_offset = vec3(rand_from_seed_m1_p1(alt_seed), 0, rand_from_seed_m1_p1(alt_seed));
		float semirandom_index = float((int(INDEX) + int(alt_seed)) % int(amount));
		
		float theta = 2.0*PI / float(amount) * float(semirandom_index);
		vec2 direction = vec2(sin(theta), cos(theta));
		
		TRANSFORM[3] = vec4(direction.x, .0, direction.y, .0) * radius;

		TRANSFORM[3] += EMISSION_TRANSFORM[3];
		
		VELOCITY.xz = direction * 0.05 + vec2(rand_from_seed_m1_p1(alt_seed), rand_from_seed_m1_p1(alt_seed)) * 0.05;
		VELOCITY.y = 40.0 * abs(rand_from_seed_m1_p1(alt_seed)) * 0.01;
	} else {
		VELOCITY.y -= DELTA / LIFETIME;// * abs(rand_from_seed_m1_p1(alt_seed));// * 0.001;
	}
}"
